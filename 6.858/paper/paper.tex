\documentclass[11pt]{article}

\usepackage{fancyhdr, geometry, hyperref, sectsty, titlesec, xspace}
\usepackage[parfill]{parskip}

\geometry{letterpaper,text={7in,9in},centering}
\pagestyle{fancy}

\sectionfont{\vspace{-2pt}\large}
\subsectionfont{\vspace{-2pt}\normalsize}
\subsubsectionfont{\normalfont\itshape}

\titlespacing\section{0pt}{10pt}{2pt}
\titlespacing\subsection{0pt}{8pt}{0pt}

\fancyhead[RO]{Carl Jackson \& Max Wang}
\fancyhead[LO]{\url{http://github.com/motmotchat/trill}}

\newcommand{\Trill}{\textsc{Trill}\xspace}
\newcommand{\Plume}{\textsc{Plume}\xspace}

\title{\Trill: Secure firewall-traversing networking}
\author{Carl Jackson \and Max Wang}
\date{December 14, 2012}

\begin{document}

\maketitle

We implemented \Trill, a networking abstraction that provides secure
communication between federated identities, either of which could be behind a
firewall.

\section{Design}

\subsection{Security}

The security of our system is based on standard cryptographic infrastructure and
libraries. By ``identities,'' we mean public key pairs, the private half of
which is uniquely known by an individual. This identity can be given one or more
names by means of X.509 certificates, and standard mechanisms like TLS allow
owners of identities to securely establish a communication channel and mutually
verify the other's identity.

\subsection{Federated Identity}

As with other federated protocols like XMPP and email, \Trill handles are based
on DNS. In particular, \Trill's handles use RFC 2822's \verb`addr-spec`
specification, in which every \verb`domain` is allowed complete control over the
\Trill handles given out as \verb`local-part`'s at their domain. Domains wishing
to run \Trill must also publish information about its \Trill servers using DNS
SRV records.

Each \Trill domain hosts a federation server, which is able to delegate
authority for identities to various clients.  Any client may present the server
with an identity and a password for that identity.  If the client's
authentication succeeds, the server signs the client's key and returns the
resultant certificate.  Using these certificates, clients can then prove their
handles securely to one another without further use of the server.

Note that the assigning of handles is orthogonal to the security of the protocol
itself, and is only useful in associating human-friendly names to their actual
cryptographic identity, i.e., their private key. Users who do not wish to use
\Trill's federated identity system can instead self-sign their certificates and
verify these credentials out-of-band. This is very similar to PGP's ``web of
trust,'' and while we have not implemented such a system, we imagine the
integration of \Trill with PGP would be trivial. An SSH-like Trust On First Use
(TOFU) system might also be viable here.

\subsection{Establishing Trust}

Trust in \Trill is established between two clients when each of them verifies
that the other client's certificate is signed by the other client's domain key.
However, the clients must also recursively verify this key, to make sure the
purported domain key was actually issued by the controller of the domain name.

This can be done in two ways. In the first, the user can use the traditional TLS
mechanism of maintaining a set of ``root'' certificate authorities, which are
securely preinstalled as part of the operating system or TLS library. The client
can verify that the domain owner certificate has a chain of trust up to a root
CA, which is sufficient to verify all end users at that domain. Note that the
entire user-to-root certificate chain cannot be verified at once, since it is
unlikely that the \Trill domain key is allowed to function as a certificate
authority; instead, by convention, a certificate issued to a domain name is
allowed by \Trill to subsequently sign the keys of users at that domain. One
could imagine an extension to X.509 that properly codified this, and although
writing RFCs is outside the scope of this project, we believe that such an
extension would be useful for a wide variety of use cases (for instance, imagine
an email service which was allowed to sign the keys of its users in this way).

The second way trust can be established is through DNSSEC, which has very
recently become mature enough to use in this way. In such a system, a domain's
\Trill root key could be published as a DNSSEC-signed TXT record. A DNS client
with the root zone signing keys can verify any DNSSEC-signed record recursively,
and in this way, discover and authenticate any \Trill key it wishes.

We believe this second mechanism is both more secure and more closely aligns
with how we are using DNS in \Trill. Since root certificate authorities are
allowed to sign keys for any common name, the compromise of a single certificate
authority is sufficient to break the security of the entire system. In contrast,
DNSSEC keys are hierarchical, such that the compromise of a single key
(``\verb`.cn.`,'' say) cannot affect the security of unrelated parts of the system
(``\verb`.com.`''), a very desirable property. Furthermore, since DNS (and
DNSSEC) is the only way to establish ``ownership'' of a domain, it makes sense
to fundamentally link trust in \Trill with trust in DNS. We consider any
individual who is allowed to make DNSSEC-signed changes to a given domain's DNS
records the ``owner'' of the domain, so a DNSSEC-rooted trust model is the most
natural fit for \Trill.

Unfortunately, while the \verb`.com.` realm is signed by DNSSEC, there are
relatively few registrars that support it. While we hope the situation improves,
it seems like CA-rooted trust is the most compatible system for implementing
\Trill in the near future, and it is what we have used in our implementation.

\subsection{Firewall Traversal}

Due to restrictions on many firewalls and NATs in place on the Internet, it is
impossible for arbitrary clients on the internet to establish peer-to-peer
communication. There are techniques for firewall/NAT traversal which involve
``tricking'' the networking layer into establishing a connection. We implemented
something similar to \texttt{chownat} (\url{http://samy.pl/chownat/}) in \Trill,
which appears to be a standard way to do this.

\section{Implementation}
% trill - client library. allows plug-and-play event loops, architected to (one
%   day!) support multiple TLS libraries.
% plume - server. separate login and protocol servers. access to domain root
%   keys has very small surface area. chroot more!

Our implementation of \Trill has two major components: a client library for
connecting to peers, and a set of server implementations which handle the
secure, federated message routing.

\subsection{Plume servers}

We break the server-side workload into two separate servers.  The first of
these is the \Plume login server.  The login server bears the full
responsibility of authenticating clients.  Each domain (or each login server on
each domain) can determine its own method for deciding whether or not to
endorse any given client's claimed identity.  This behavior is unspecified by
\Trill; the login server can only endorse identities in its domain, but can
endorse them however it sees fit.

The actual process of ``logging in'' requires a client to send the login server
a X.509 certificate signing request (CSR).  The login server, if it so chooses,
can then endorse the client's identity by signing a cert and returning it to
the user.  The client uses cert whenever it connects to \Plume protocol servers
or to peers in order to assert its identity.  These servers and parties can
then walk their way up the chain of trust to verify the user's identity and the
authority of the login server that endorsed it.

With this cert, the client is then able to connect to the \Plume protocol
servers.  These servers will only talk over TLS to clients with valid
identities (connections to the login servers are also secured by TLS, but only
the login server's cert is used).  These \Plume servers server two major
purposes:

\begin{enumerate}
  \item Message routing.  Clients can ask their \Plume servers to pass messages
    to peers.  If they are on the same domain and are connected to the server,
    the message is routed directly; otherwise, the message is forwarded first
    to the proper server
\end{enumerate}

Discovery of server addresses and ports

\subsection{Trill client library}
The \Trill client library is fairly straightforward. Its job is simply to open a
UDP socket, perform a \verb`chownat`-like discovery protocol (which we call
``probing''), and then perform a DTLS handshake. The probing protocol is the
only non-obvious part of this. In particular, since TLS demands that one party
act as the server and the other as the client, the probing protocol must somehow
decide on a winner and a loser. Unfortunately, a result from the distributed
systems literature tells us that it is impossible for two parties to both agree
on even a single bit of information on a lossy out-of-order channel like UDP, so
the cause seems like a lost one. However, in practice, it is possible to use
DTLS's retry behavior, combined with non-colliding message types and
drop-on-error packet parsing semantics, to work around this. Both parties
generate random 64-bit numbers, and the client with the larger number is the
winner. If a client discovers it is the winner, it transitions to the ``server''
state, in which it attempts to read (and parse) DTLS handshake records, but
continues to send probes to its peer at regular intervals. If a client discovers
that it is the loser, and that its peer has acknowledged this fact (an extra bit
in the message), it transitions to ``client'' mode, in which it attempts a DTLS
handshake, discarding probe packets it receives. The asymmetry around the
acknowledge bit and the timeouts allow us to guarantee protocol progress in the
limiting case.

We wanted the \Trill client library to be as flexible as possible, and a large
portion of the implementation effort was spent making sure the library was
separated from both the particulars of the event loop implementation and the
choice of cryptographic library. Clients of \Trill must pass in a table of
function pointers which allow \Trill to be notified of various event loop
events, such as socket read/write availability and timers.  Secondly, the choice
of cryptographic library is controllable via a preprocessor flag, and \Trill
implementations can provide several of them in the hopes of greater
compatibility. Although we only provided implementations for Glib and GnuTLS
(the libraries that \verb`libpurple`, a popular instant messaging application
uses, which was the use case we originally envisioned for \Trill), a brief
perusal of the APIs for \verb`libev`, \verb`libevent`, OpenSSL, and NSS confirms
that the abstractions we expose in \Trill are sufficiently general to allow any
combination of event loop and TLS implementation to be used.

\end{document}
